## GaugeV3.sol

The `Gauge` contract is a rewards gauge for a specific `ClPool`. Its primary purpose is to distribute various reward tokens to users who have provided liquidity to that pool and staked their positions.

**Key Functionality:**

- `Rewards`: The gauge can distribute multiple types of reward tokens. A central `voter.sol` contract manages the list of official reward tokens.
- `Weekly Periods`: Rewards are accounted for and distributed in weekly intervals or "periods".
- `notifyRewardAmount()`: This is a crucial function where an external entity (like a rewards distributor) can add a specific `amount` of a `token` to the gauge's reward pool for the current week.
- `earned()`: This view function allows anyone to check the amount of a specific reward `token` that a particular user's position (`tokenId`) has accumulated but not yet claimed.
- `getReward()`: allows a user to claim their accumulated rewards for one or more tokens.
- `pushFees()` Modifier: This is where the interaction with the `FeeCollector` begins. The `notifyRewardAmount` function is decorated with a `pushFees` modifier. This means that every time new rewards are added to the gauge, it _first_ triggers the fee collection process.

## FeeCollector.sol

The `FeeCollector.sol` contract is responsible for collecting protocol fees from the `RamsesV3Pool` and directing them to the correct destinations.

`collectProtocolFees()`: called by the `GaugeV3` contract's `pushFees` modifier. Here's what it does:

1.  `Fetches Pending Fees`: It checks the associated `RamsesV3Pool` for any accumulated protocol fees.
2.  `Checks for a Gauge:` It queries the `voter` contract to get an active gauge associated with the pool.
3.  `Direct to Treasury (No Gauge):` If there's no active gauge for the pool,
    it assumes there's no one to distribute fees to, so it sends 100% of the collected fees directly to the `treasury`.
4.  `Splits Fees (With Gauge):` If there is an active gauge, it collects the fees and then splits them:
    - A portion goes to the `treasury` (the percentage is configurable).
    - The remainder is sent to a `feeDistributor` contract, which is also determined by the `voter` contract.
      The `feeDistributor` is then responsible for distributing these fees to the users who are staked in the gauge.

### How They Work Together: The Flow

Here is the step-by-step process of how these two contracts interact:

1.  **Rewards are Added:** An external actor calls `notifyRewardAmount()` on a `CLGauge` contract to deposit new reward tokens.
2.  **pushFees() is Triggered:** Before the `notifyRewardAmount` logic executes, its `pushFees` modifier is invoked.
3.  **Fee Collection is Initiated:** The `pushFees` modifier calls the `collectProtocolFees()` function on the `FeeCollector` contract,
    passing in the `RamsesV3Pool` associated with the gauge.
4.  **Fees are Collected and Split:** The `FeeCollector` gathers the protocol fees from the pool.
    It then sends a portion to the `treasury` and the rest to the appropriate `feeDistributor`.
5.  **Rewards are Distributed:** The `feeDistributor` receives the fees and makes them available as rewards for the users staked in the `GaugeV3` contract.
6.  **Original Reward is Processed:** After the fee collection process is complete,
    the original `notifyRewardAmount` function in `GaugeV3` finishes executing,
    adding the new rewards to the gauge for the current period.

In essence, every time new rewards are added to a gauge, it triggers a "side-process" that first collects and distributes the protocol fees that have been generated by the underlying liquidity pool.
This creates a symbiotic relationship where the act of rewarding liquidity providers also ensures that the protocol itself (via the treasury) and the stakers are receiving their share of the fees.
The `voter` contract acts as the central orchestrator, linking everything together.
